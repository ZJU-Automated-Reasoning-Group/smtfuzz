import multiprocessing
import subprocess
import os,sys
import random
import inspect
import string
import time
from analyzer.spc_analyzer import *
from fuzzer.evaluator import *
from termcolor import colored
from interval import interval, inf, imath
from parser.smt_parser import *
from utils.debug import *
from utils.solver import *
from utils.cvc5Interface import *
import signal
import copy

def get_logic(logic):
    logic_ = 0
    if "ALL"==logic:
        logic_ = (logic_ | 127)
    if "S" in logic:
        logic_ = (logic_ | 4)
    if "I" in logic:
        logic_ = (logic_ | 2)
    if "R" in logic:
        logic_ = (logic_ | 1)
    return logic_

def get_theory(logic):
    theory_ = 0
    if "ALL" == logic:
        theory_ = (theory_ | 127)
    if "T" in logic and "A" in logic:
        theory_ = (theory_ | 8)
    if "DL" in logic:
        theory_ = (theory_ | 4)
    if "N" in logic and "A" in logic:
        theory_ = (theory_ | 2)
    if "L" in logic and "A" in logic:
        theory_ = (theory_ | 1)
    return theory_

def gen_variable(size=5):
    chars="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    start = "0123456789_"
    var = random.choice(chars)+''.join(random.choice(chars+start) for _ in range(size)) 
    return var

class TimeOutException(Exception):
    pass

def alarm_handler(signum, frame):
    raise TimeOutException()

@trace
class MutantGenerator(object):
    def __init__(self, seed_data, solver_data, formula_data, file_data, info, max_iteration, mode, experiment, debug = None):
        ### Seed Information 
        self.seed_var = seed_data["seed_var"]
        self.seed_const = seed_data["seed_const"]
        self.logic = get_logic(seed_data["logic"])
        self.theory = get_theory(seed_data["logic"])
        
        ## Solver Information
        self.data = solver_data["data"]
        self.e = None
        self.model = solver_data["model"]
        self.solver = solver_data["solver"]
        self.solver_vars = solver_data["vars"]
        ### Sub Formula Information which will be mutated.
        self.max_iteration = max_iteration

        self.node = info[0] # mutation target node
        self.term = info[1] # mutation target term
        self.type = info[2] # term constraint
        self.line = formula_data["line"] # mutation target line
        self.ast = copy.deepcopy(formula_data["ast"]) # mutation assert formula's ast
        
        
        self.t_fresh_var = {} # for fresh variable generated by Complicate
        self.t_var_list = []
        self.t_var_type = {} # list of type for variable within temporary mutant term
        self.t_const_type = {} # list of type for constant within temporary mutant term
        self.mutant_term_ast = None
        self.mutant_ast = None
        self.v = 0

        ### Mutant File Info
        self.org_path = file_data["file_path"]
        self.mutant_cnt = file_data["iter"]
        self.mutant_path = file_data["mutant_path"]

        self.gen_time = 0.0
        self.judge_time = 0.0

        ### Fuzzing Option
        self.debug = debug
        self.mode = mode
        self.experiment = experiment

        self.timeout_cnt = 0
        self.gen_res = False

    def gen_mutant(self):
        iter = 0
        start_time = time.time()
        try:
            for i in range(50):
                if time.time() - start_time >= 900.0:
                    return "Fail", iter
                iter += 1
                
                self.prev_clear()

                ## generation
                gen_start = time.time()
                candidate_term = self.syn_mutant_term()
                self.gen_time += time.time()-gen_start
                if candidate_term is None:
                    continue

                if self.mode == "nooracle":
                    if random.randint(1,1000)%2==0:
                        try:
                            new_term = self.complicate(candidate_term)
                            candidate_term = new_term
                        except Exception as e:
                            pass
                    mutant_file = self.gen_mutant_file(candidate_term)
                    if mutant_file is None:
                        continue
                    return mutant_file, iter, candidate_term, self.judge_time, self.gen_time
 
                judge_start = time.time()
                res = self.validate_term(candidate_term)
                self.judge_time += time.time() - judge_start

                if res:
                    if self.mode != "nocomp" and random.randint(1,1000)%2==0:
                        try:
                            new_term = self.complicate(candidate_term)
                            candidate_term = new_term
                        except Exception as e:
                            pass
                    mutant_file = self.gen_mutant_file(candidate_term)
                    if mutant_file is None:
                        continue
                    return mutant_file, iter, candidate_term, self.judge_time, self.gen_time
                    
            return "Fail", iter, None, self.judge_time, self.gen_time
        except Exception as e:
            return "Fail", iter, None, self.judge_time, self.gen_time

    def syn_mutant_term(self):
        if self.type == "Bool":
            term = self.gen_formula(0)
        elif self.type == "Real":
            term = self.gen_real_term(0)
        elif self.type == "Int":
            term = self.gen_int_term(0)
        elif self.type == "String":
            term = self.gen_string_term(0)
        elif self.type == "RegLan":
            term = self.gen_regp_term(0)
        else:
            term = None
        return term

    def validate_term(self, candidate_term):
        res = False
        mutant_term_ast = getTermAST(candidate_term) 
        self.mutant_term_ast = mutant_term_ast
        t_ast = copy.deepcopy(self.ast)
        t_mutant, mutant_ast, _ = self.mutate_term(t_ast,0,candidate_term, mutant_term_ast[0])
        self.v = 0
        self.mutant_ast = mutant_ast
        try:
            if self.solver == "z3":
                res = multiprocessing.Value('i', 0)
                proc = multiprocessing.Process(target=self.z3_evaluation,args=(t_mutant,res))
                proc.start()
                proc.join(timeout=5)
                if proc.is_alive():
                    self.timeout_cnt += 1
                    proc.terminate()
                return (res.value==1)
            elif self.solver == "cvc":
                mutant = ast_to_cvc5(mutant_ast,self.model, self.data, self.logic)
                if mutant is None:
                    return False
                signal.signal(signal.SIGALRM, alarm_handler)
                signal.alarm(10)
                try:
                    res = (str(self.model.getValue(mutant))=="true")
                    return res
                except TimeOutException as e:
                    return False
            else:
                eval = ConstraintAnalyzer(mutant_term_ast,self.solver_vars,self.model,self.logic)
                term_evaluation = eval.validate()
                if term_evaluation is None:
                    return False
                
                self.e = copy.deepcopy(self.data[0])
                self.e[self.node][0]= term_evaluation

                res = self.bottom_up_eval(term_evaluation,self.node)
                if res is None:
                    return False
                return res
        except Exception as e:
            trace = inspect.trace()
            fn = trace[-1].filename
            lineno = trace[-1].lineno
            print(candidate_term,self.org_path)
            print(fn,lineno,e)
            print("[Line 125] Validate Term Error : {}".format(e))
            self.timeout_cnt += 1
            return False

    def z3_evaluation(self,t_mutant,shared_data):
        mutant = "(assert "+t_mutant+")"
        t_formula = self.data+mutant
        z3_ast = parse_smt2_string(t_formula)
        res = self.model.evaluate(z3_ast[0],model_completion=True)
        if is_true(res) or is_false(res):
            res = is_true(res)
        else:
            res = False
        
        shared_data.value = 1 if res else 0
        return


    def complicate(self, candidate_term):
        complex_term = candidate_term
        tmp_var_const = list(self.t_var_type.keys())+list(self.t_const_type.keys())

        if len(tmp_var_const) == 0:
            return complex_term
        
        choiceCount = max(1, min(len(tmp_var_const),3))
        selection = random.sample(tmp_var_const, random.randint(1,choiceCount))
        fresh_dict = {}

        for sub in selection:
            try:
                term_type = self.t_var_type[sub] if (sub in self.t_var_type) else self.t_const_type[sub]
                if not(term_type in ["Int","Real"]):
                    continue
                if sub in self.t_var_type:
                    if self.solver == "z3":
                        if is_algebraic_value(self.model[self.solver_vars[sub]]):
                            continue
                        tmp = str(self.model[self.solver_vars[sub]])
                        if tmp[-1]=='?':
                            continue
                        
                        if "/" in tmp:
                            a = tmp.split("/")
                            if a[0][0]=="(":
                                tmp1 = -float(a[0][3:-1]) 
                            else:
                                tmp1 = float(a[0])

                            if a[1][0] =="(":
                                tmp2 = -float(a[1][3:-1])
                            else:
                                tmp2 = float(a[1])
                            
                            res = tmp1/tmp2

                            if res < 0.0:
                                res = "(- "+str(abs(res))+")"
                            else:
                                res = str(res)
                            term_val = [res, True, "(/ a[0] a[1])"]
                        elif tmp==sub:
                            continue
                        else:
                            term_val = [tmp,False]
                            if term_val[0] is None:
                                continue
                    elif self.solver == "cvc":
                        term_val =[str(self.model.getValue(self.model.getValue(self.solver_vars[sub]))), False]
                    else:
                        term_val = [self.model[sub][0][0], False]
                else:             
                    if not sub.isnumeric(): 
                        continue
                    if term_type == "Int":
                        if sub[0] == "(":
                            term_val = ["-"+sub[3:-1], False]
                        else:
                            term_val = [sub, False]
                    else:
                        if sub[0] == "(":
                            term_val = ["-"+sub[3:-1], False]
                        else:
                            term_val = [sub, False]
                if term_val[0] == "None":
                    #print(term_val, sub, self.model)
                    continue
                fresh_var = self.gen_fresh_var(term_type, term_val)
                fresh_dict[sub] = [fresh_var,True]
            except Exception as e:
                trace = inspect.trace()
                fn = trace[-1].filename
                lineno = trace[-1].lineno
                print("complicate error")
                print(fn,e,lineno)
                print(term_val)
                continue 
        if len(list(fresh_dict.keys()))==0:
            return candidate_term
        complex_term = self.replace_term(self.mutant_term_ast[0], fresh_dict)
        if len(complex_term)==0:
            self.t_fresh_var.clear()
            return candidate_term
        return complex_term

    def gen_mutant_file(self,mutant_term):
        file_name = self.org_path.split('/')[-1]
        f = open(self.org_path, "r", encoding='utf-8')
        seed = f.read().splitlines()
        f.close()
        if len(seed) == 0:
            return None
        
        mutant_file = os.path.join(self.mutant_path,"mutant_"+str('{:03d}'.format(self.mutant_cnt))+".smt2")
        m_f =  open(mutant_file, mode='w',encoding='utf-8')
        
        idx = -1
        for i in range(len(seed)):
            if "assert" in seed[i]:
                idx = i
                break
            m_f.write(seed[i]+"\n")

        fresh_var = list(self.t_fresh_var.keys())

        if len(fresh_var) != 0 :
            constraint_cmd = ""
            for v in fresh_var:
                ty, bound = self.t_fresh_var[v]
                declare_stmt = "(declare-fun "+v+" () "+ty+")\n"
                m_f.write(declare_stmt)

                lo, up = bound.split(',')
                lo = lo[1:]
                up = up[:-1]
                if float(lo)<0.0:
                    lo = "(- "+lo[1:]+")"
                
                if float(up) < 0.0:
                    up = "(- "+up[1:]+")"

                l_constraint_stmt = "(<= "+lo+" "+v+")"
                r_constraint_stmt = "(<= "+v+" "+up+")"
                constraint_cmd+=" "+l_constraint_stmt+" "+r_constraint_stmt
            constraint_cmd = "(assert (and"+constraint_cmd+"))\n"
            m_f.write(constraint_cmd)

        try:
            prev = seed[idx]
            for i in range(idx,len(seed)):
                if i == int(self.line):
                    self.v = 0
                    t_ast = copy.deepcopy(self.ast)
                    mutant_str, _, _  = self.mutate_term(t_ast,0,mutant_term)
                    replace_assert = "(assert "+mutant_str+")\n"
                    m_f.write(replace_assert)
                    prev = replace_assert
                else:
                    if seed[i] == "(get-model)" and prev!="(check-sat)":
                        m_f.write("(check-sat)\n")
                    m_f.write(seed[i]+"\n")
                    prev = seed[i]
        except Exception as e:
            trace = inspect.trace()
            fn = trace[-1].filename
            lineno = trace[-1].lineno
            return None
        m_f.close()
        return mutant_file
    
    #####
    def mutate_term(self,ast,depth,mutant_term, mutant_ast = None):
        self.v += 1
        ty = ast.__class__.__name__
        if ast[0] == "(":
            term = ast[1:-1]
        else:
            term = ast    
    
        node = self.labeling(ty, term, depth)
        if node == self.node:
            return mutant_term, mutant_ast, node
        
        tmp = term[1:]
        sub_terms = []

        idx = 2
        for sub in tmp:
            sub_term, sub_ast, c_node = self.mutate_term(sub, depth+1, mutant_term, mutant_ast)
            sub_terms.append(sub_term)
            if not(mutant_ast is None) and self.node == c_node:
                ast[idx] = sub_ast
            idx+=1
        
        if len(sub_terms) == 0:
            return term[0], ast, node
        
        formula = "("+term[0]
        for sub in sub_terms:
            formula+=" "+sub
        formula+=")"

        return formula, ast, node


    def labeling(self, ty, term ,depth):
        if ty == "R_Operator" or ty == "_Operator":
            return self.line+"_"+term[2][1]+"_"+str(self.v)+"_"+str(depth)
        
        node = term[0]+"_"+str(self.v)+"_"+str(depth)
        if ty in ["Constant","Const_String","RegLan","Bool"]:
            node = "const_"+node
        node = self.line+"_"+node
        return node

    ##### Generation Term Part
    def gen_formula(self,depth):
        logic_op = ["None", "not", "and","or","=>","xor"]
        op = random.choice(logic_op)
        sub_terms = []
        if op == "None":
            return self.gen_bool_term(depth)
        elif op == "not":
            sub_terms.append(self.gen_bool_term(depth+1))
        elif op == "=>":
            sub_terms.append(self.gen_bool_term(depth+1))
            sub_terms.append(self.gen_bool_term(depth+1))
        else:
            k = random.randint(2,5)
            for i in range(k):
                sub_terms.append(self.gen_bool_term(depth+1))
        
        term = "("+op
        for sub in sub_terms:
            if sub is None:
                print("Formula Return None", op, sub)
                return None
            term+=" "+sub
        term +=")"
        return term
    
    def gen_bool_term(self,depth):
        # operators which have boolean type of return
        # leaf is variable or constant
        bool_op = ["=","distinct","<","<=",">=",">"]

        if depth > 1:
            bool_op+=["true","false"]
        
        if self.logic >= 4:
            bool_op += ["str.<","str.in_re","str.<=","str.prefixof","str.suffixof","str.contains","str.is_digit"]
        elif self.logic == 3:
            bool_op += ["is_int"]

        op = random.choice(bool_op)

        sub_terms = []
        if op in ["true","false"]:
            self.t_const_type[op] = "Bool"
            return op
        elif op in ["=","distinct"] and self.logic >=4:
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
        elif op in ["=","distinct","<","<=",">=",">"]:
            sub_terms.append(self.gen_arith_term(depth+1))
            sub_terms.append(self.gen_arith_term(depth+1))
        elif op == "is_int":
            sub_terms.append(self.gen_real_term(depth+1))
        elif op in ["str.<","str.<=","str.prefixof","str.suffixof","str.contains"]:
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
        elif op == "str.in_re":
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_regp_term(depth+1))
        elif op == "str.is_digit":
            sub_terms.append(self.gen_string_term(depth+1))
        else:
            print("Boolean Return None", op)
            return None

        term = "("+op
        for sub in sub_terms:
            if sub is None:
                return None
            term+=" "+sub
        term+=")"
        return term

    def gen_arith_term(self,depth):
        if self.logic == 3:
            if random.randint(1,3)%2==0:
                return self.gen_int_term(depth)
            else:
                return self.gen_real_term(depth)
        elif self.logic&2 !=0:
            return self.gen_int_term(depth)
        elif self.logic == 1:
            return self.gen_real_term(depth)
        return None

    def gen_real_term(self,depth):
        # operators which have real type of return
        # leaf is variable or constant

        real_var = list(self.seed_var["Real"])
        real_const = list(self.seed_const["Real"])

        real_op = ["leaf","+","-","ite"]
        
        if self.theory >= 2:
            real_op += ["*","/","abs"]
            if self.theory >= 8 and self.solver == "cvc" and self.mode != "nospec":
                real_op += ["sqrt","exp","sin","cos","tan","csc","sec","cot",
                    "arcsin","arccos","arctan","arcsc","arcsec","arccot","real.pi"]
        
        if self.logic == 3:
            real_op += ["to_real"]
        if self.solver == "dreal" and self.mode != "nospec":
            real_op += ["sin","cos","tan","sinh","cosh","tanh","arcsin","arccos","arctan",
                    "exp","log","sqrt","pow","arctan2"]


        op = random.choice(real_op)
        if (depth >= self.max_iteration or op == "leaf") and len(real_var+real_const) != 0 :
            term = random.choice(real_var+real_const)
            if term in real_const:
                if float(term)<0:
                    term = "(- "+str(abs(float(term)))+")"
                self.t_const_type[term] = "Real"
            else:
                self.t_var_type[term] = "Real"
            
            if random.randint(1,5)%4==0:
                term = "(- "+term+")"
            return term

        sub_terms = []
        if op == "to_real":
            sub_terms.append(self.gen_int_term(depth+1))
        elif op in ["pow","arctan2","+","-","*","/"]:
            sub_terms.append(self.gen_real_term(depth+1))
            sub_terms.append(self.gen_real_term(depth+1))
        elif op == "ite":
            sub_terms.append(self.gen_bool_term(depth+1))
            sub_terms.append(self.gen_real_term(depth+1))
            sub_terms.append(self.gen_real_term(depth+1))
        else:
            sub_terms.append(self.gen_real_term(depth+1))

        term = "("+op
        for sub in sub_terms:
            if sub is None:
                return None
            term +=" "+sub
        term+=")"

        return term

        
    def gen_int_term(self,depth):
        # operators which have integer type of return
        # leaf is variable or constant
        int_var = list(self.seed_var["Int"])
        int_const = list(self.seed_const["Int"])

        int_op = ["leaf","+","-","ite"]

        if self.theory >= 2:
            int_op += ["*","div","mod","abs"]
            if self.solver == "cvc":
                int_op+=["int.pow2"]
        elif self.experiment == "1" and self.solver == "cvc" and self.mode != "nospec":
            int_op+=["int.pow2"]
        
        if self.logic >= 4 :
            int_op += ["str.len","str.indexof","str.to_code","str.to_int"] 
            if self.solver == "cvc" and self.mode != "nospec":
                int_op += ["str.indexof_re"]

        if self.logic == 3:
            int_op += ["to_int"]

        op = random.choice(int_op)

        if (depth >= self.max_iteration or op == "leaf") and len(int_var+int_const) != 0 :
            term = random.choice(int_var+int_const)
            
            if term in int_const:
                self.t_const_type[term] = "Int"
            else:
                self.t_var_type[term] = "Int"
            
            if random.randint(1,5)%4==0:
                term = "(- "+term+")"
            return term

        sub_terms = []
        if op == "to_int":
            sub_terms.append(self.gen_real_term(depth+1))
        elif op == "str.indexof":
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
        elif op == "str.indexof_re":
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_regp_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
        elif op == "iand":
            sub_terms.append(str(random.randint(1,33)))
            sub_terms.append(self.gen_int_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
            term = "((_ "+op+" "+sub_terms[0]+") "+sub_terms[1]+" "+sub_terms[2]+")"
            return term
        elif op in ["str.len","str.to_code","str.to_int"]:
            sub_terms.append(self.gen_string_term(depth+1))
        elif op in ["abs","int.pow2"]:
            sub_terms.append(self.gen_int_term(depth+1))
        elif op in ["div","mod","+","-","*"]:
            sub_terms.append(self.gen_int_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
        elif op =="leaf" or depth >= self.max_iteration:
            term = random.randint(-20,20)
            if term<0:
                return "(- "+str(abs(term))+")"
            else:
                return str(term)
        elif op == "ite":
            sub_terms.append(self.gen_bool_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
        else:
            print("Int Return None", op)
            return None

        term = "("+op
        for sub in sub_terms:
            if sub is None:
                print("Int For Loop",op)
                return None
            term+=" "+sub
        term +=")"
        return term

    def gen_string_term(self,depth):
        # operators which have string type of return
        # leaf is variable or constant
        str_var = list(self.seed_var["String"])
        str_const = list(self.seed_const["String"])

        string_op = ["leaf", "str.++", "str.at", "str.substr", "str.replace", "str.from_code", "str.from_int","ite"]
        if self.solver == "cvc" and self.mode != "nospec":
            string_op += ["str.update", "str.rev", "str.to_lower", "str.to_upper","str.replace_re","str.replace_all","str.replace_re_all"]
        op = random.choice(string_op)

        if (depth >= self.max_iteration or op == "leaf") and len(str_var+str_const)!=0:
            term = random.choice(str_var+str_const)
            if term in str_var:
                self.t_var_type[term] = "String"
            else:
                self.t_const_type[term] = "String"
            return term

        sub_terms = []
        if op == "str.++":
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
        elif op == "str.at":
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
        elif op == "str.substr":
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
        elif op == "str.update":
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_int_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
        elif op in ["str.replace","str.replace_all"]:
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
        elif op in ["str.replace_re","str.replace_re_all"]:
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_regp_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
        elif op in ["str.from_code","str.from_int"]:
            sub_terms.append(self.gen_int_term(depth+1))
        elif op in ["str.rev","str.to_lower","str.to_upper"]:
            sub_terms.append(self.gen_string_term(depth+1))
        elif op == "ite":
            sub_terms.append(self.gen_bool_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
            sub_terms.append(self.gen_string_term(depth+1))
        else:
            print("String Return None", op)
            return None
        
        term = "("+op
        for sub in sub_terms:
            if sub is None:
                return None
            term+=" "+sub
        term+=")"
        return term    

    def gen_regp_term(self,depth):
        # operators which have reglan type of return
        regp_op = ["str.to_re","re.none","re.all","re.allchar","re.++","re.union","re.inter","re.*","re.comp",
            "re.diff","re.+","re.range", "re.^","re.loop","re.opt"]

        if self.solver == "z3" and self.mode != "nospec":
            regp_op.append("ite")
        op = random.choice(regp_op)

        if depth >= self.max_iteration:
            return random.choice(["re.none","re.allchar","re.all"])

        sub_terms = []
        if op in ["re.none","re.all","re.allchar"]:
            return op
        elif op in ["str.to_re"]:
            sub_terms.append(self.gen_string_term(depth+1))
        elif op in ["re.*","re.+","re.comp","re.opt"]:
            sub_terms.append(self.gen_regp_term(depth+1))
        elif op in ["re.++","re.union","re.inter","re.diff"]:
            sub_terms.append(self.gen_regp_term(depth+1))
            sub_terms.append(self.gen_regp_term(depth+1))
        elif op == "re.range":
            asscii_low = [i for i in range(65,91)]
            asscii_big = [i for i in range(97,123)]
            asscii_number = [i for i in range(48,58)]

            while True:
                r1 = random.randint(48,123)
                if r1 in asscii_low+asscii_big+asscii_number:
                    break
            
            while True:
                r2 = random.randint(48,123)
                if r2 in asscii_low+asscii_big+asscii_number:
                    break

            l = str(chr(min(r1,r2)))
            u = str(chr(max(r1,r2)))
            sub_terms.append('"'+l+'"')
            sub_terms.append('"'+u+'"')
        elif op == "ite":
            sub_terms.append(self.gen_bool_term(depth+1))
            sub_terms.append(self.gen_regp_term(depth+1))
            sub_terms.append(self.gen_regp_term(depth+1))
        elif op == "re.^":
            return "re.allchar"
        elif op == "re.loop":
            return "re.allchar"
        else:
            print("RegLan Return None", op)
            return None
        
        term = "("+op
    
        for sub in sub_terms:
            if sub is None:
                return None
            term+=" "+sub
        term +=")"
        return term

        
    def gen_fresh_var(self,term_type, term_val):
        fresh_var = gen_variable()

        while(fresh_var in self.t_var_list):
            fresh_var = gen_variable()
            
        if self.solver =="dreal":
            i1 = 0
            i2 = 0
            if term_type == "Real":
                i1 = float(int(random.randint(0,101)-50.0))
                i2 = term_val
            elif term_type == "Int":
                i1 = random.randint(0,101)-50
                i2 = term_val
            else:
                return ""

            lo = min(i1,i2)
            up = max(i1,i2)
            if lo == i1:
                self.t_fresh_var[fresh_var] = [term_type, "["+str(lo)+","+str(up)+"]"]
            else:
                self.t_fresh_var[fresh_var] = [term_type, "["+str(lo)+","+str(up)+"]"]
            self.t_var_list.append(fresh_var)
        else:
            i1 = 0
            i2 = 0
            if term_type == "Real":
                i1 = float(int(random.randint(0,101)-50.0))
                if term_val[0][0:2] == "(-":
                    i2 = -float(term_val[0][3:-1])
                else:
                    i2 = float(term_val[0])
            elif term_type == "Int":
                i1 = random.randint(0,101)-50
                if term_val[0][0:2] == "(-":
                    i2 = -int(term_val[0][3:-1])
                else:
                    i2 = int(term_val[0])
            else:
                return ""

            lo = min(i1,i2)
            up = max(i1,i2)
            if lo == i1:
                if term_val[1]:
                    self.t_fresh_var[fresh_var] = [term_type, "["+term_val[2]+","+str(up)+"]"]
                else:
                    self.t_fresh_var[fresh_var] = [term_type, "["+str(lo)+","+str(up)+"]"]
            else:
                if term_val[1]:
                    self.t_fresh_var[fresh_var] = [term_type, "["+str(lo)+","+term_val[2]+"]"]
                else:
                    self.t_fresh_var[fresh_var] = [term_type, "["+str(lo)+","+str(up)+"]"]
            self.t_var_list.append(fresh_var)

        return fresh_var

        

    def replace_term(self, ast, fresh_dict):
        if ast[0]=="(":
            ast = ast[1:-1]

        sub_ast = ast[1:]
        sub_trees = []

        for s_ast in sub_ast:
            sub_trees.append(self.replace_term(s_ast,fresh_dict))
        
        if len(sub_trees)==0:
            if ast[0] in fresh_dict and fresh_dict[ast[0]][1] == True:
                fresh_dict[ast[0]][1]=False
                return fresh_dict[ast[0]][0]
            else:
                return ast[0]
        else:
            formula = "("+ast[0]
            for s in sub_trees:
                formula+=" "+s
            formula+=")"
            return formula

    def prev_clear(self):
        self.t_fresh_var.clear()
        self.t_var_list.clear()
        self.t_var_type.clear()
        self.t_const_type.clear()
        self.v = 0
        self.t_var_list = list(self.seed_var["Real"])+list(self.seed_var["Bool"])+list(self.seed_var["Int"])+list(self.seed_var["String"])
        self.mutant_ast = None
        self.mutant_term_ast = None
    


    def bottom_up_eval(self,evaluation,node):
        p = self.data[1][node]
        if p is None or evaluation is None:
            return evaluation

        op = '_'.join(p.split('_')[1:-2])
        tmp_e = []
        tmp_t = []
        for data in self.data[2][p]:
            if data[0]==node:
                tmp_e.append(evaluation)
            else:
                tmp_e.append(self.e[data[0]][0])
            tmp_t.append(self.e[data[0]][1])
        res = self.eval(op,tmp_e,tmp_t)
        return res


    def eval(self,op,E,T):
        if op in ["not", "and","or","=>","xor"]:
            e,_ = eval_logic_op(op,E,T)
        elif op in ["=","distinct","<","<=",">=",">"]:
            e,_ = eval_cop_op(op,E,T)
        elif op in ["tanh","cosh","sinh","arctan2","atan2","arctan","atan","arccos","acos","arcsin","asin","tan","cos",
                "sin","log","exp","to_real","/","csc","sec","cot","arccsc","arcsec","arccot","real.pi"]:
            e,_ = eval_real_op(op,E,T)
        elif op in ["to_int","div","mod","int.pow2","iand"]:
            e,_ = eval_int_op(op,E,T)
        elif op in ["pow","^","sqrt","max","min","abs","*","-","+"]:
            e,_ = eval_arith_op(op,E,T)
        else:
            e,_ = (None,None)
        return e


    
