# coding: utf-8
"""
This script defines a class Z3Mutation that can be used to generate mutants of SMT-LIB2 formulas. 

The class has several methods that implement different mutation strategies. The main function of
the script takes an input SMT-LIB2 file, applies a mutation strategy to it, and outputs the resulting mutant to a file.

The mutation strategy can be specified using the --mode argument. 
- The "quant" strategy adds quantifiers to the formula
- The "cube" strategy generates mutants by enumerating cubes from the CNF of the formula
- The "domain" strategy adds abstract domain constraints to the formula
- The "random" strategy randomly selects one of the other three strategies.
"""

import argparse
import itertools
import random

from z3 import *
# from z3.z3util import get_vars  # this one is slow


def get_vars(exp):
    try:
        syms = set()
        stack = [exp]

        while stack:
            e = stack.pop()
            if z3.is_app(e):
                if e.num_args() == 0 and e.decl().kind() == z3.Z3_OP_UNINTERPRETED:
                    syms.add(e)
                else:
                    # Add children in reverse order
                    # This maintains DFS traversal order when using pop()
                    # stack.extend(reversed(e.children())) # shoud we?
                    stack.extend(e.children())

        return list(syms)
    except z3.Z3Exception as ex:
        print(ex)
        return False


def get_atoms(z3expr):
    """
    Get all atomic predicates in a formula
    """
    s = set()

    def get_atoms_(exp):
        if exp in s:
            return
        if is_not(exp):
            s.add(exp)
        if is_and(exp) or is_or(exp):
            for e_ in exp.children():
                get_atoms_(e_)
            return
        assert (is_bool(exp))
        s.add(exp)

    # convert to NNF and then look for preds
    ep = Tactic('nnf')(z3expr).as_expr()
    get_atoms_(ep)
    return s


def string2file(fn, string):
    """
    Output strint to a file fn
    """
    with open(fn, "w") as f:
        f.write(string)


def get_script_from_file(file):
    """
    Parse an SMT-LIB2 file as string (use the parser from OpFuzz)
    """
    with open(file, "r") as reader:
        script = reader.read()
        return script


def shift_script(script):
    """
    Remove set-option, etc.
    script is a string (generated by get_script_from_fie)
    """
    # return script
    script_text = script.split('\n')
    new_script_text = ""
    for line in script_text:
        if not ("set-option" in line or "set-info" in line):
            new_script_text = new_script_text + "\n" + line
    return new_script_text


class Z3Mutation:
    def __init__(self):
        self.logic = None
        self.success = False
        self.formula = None
        self.assertions = []  # all asserts (one aseert can be complex)
        self.vars = []  # all vars
        self.preds = []  # all atoms
        self.optfuzz = "no"
        self.has_quantifier = False

        self.z3option = False
        self.cvc4option = False

    def apply_probe(self, name):
        g = Goal()
        g.add(self.formula)
        p = Probe(name)
        return p(g)

    def has_quant(self):
        return self.apply_probe('has-quantifiers')

    def get_logic(self):
        try:
            if not self.has_quantifier:
                if self.apply_probe("is-qfbv"):
                    return "QF_BV"
                if self.apply_probe("is-qfaufbv"):
                    return "QF_AUFBV"
                elif self.apply_probe("is-lia"):
                    return "QF_LIA"
                elif self.apply_probe("is-lra"):
                    return "QF_LRA"
                elif self.apply_probe("is-qfnia"):
                    return "QF_NIA"
                elif self.apply_probe("is-qfnra"):
                    return "QF_NRA"
                elif self.apply_probe("is-qfufnra"):
                    return "QF_UFNRA"
                else:
                    return "ALL"
            else:
                if self.apply_probe("is-nia"):
                    return "NIA"
                elif self.apply_probe("is-nra"):
                    return "NRA"
                elif self.apply_probe("is-nira"):
                    return "NIRA"
                elif self.apply_probe("is-lia"):
                    return "LIA"
                elif self.apply_probe("is-lra"):
                    return "LRA"
                elif self.apply_probe("is-lira"):
                    return "LIRA"
                else:
                    return "ALL"
        except Exception as ex:
            return "ALL"

    def to_sat_formula(self):
        if self.success:
            sol = Solver()
            sol.add(self.formula)
            # 2 second? or 2000 seconds?
            sol.set("timeout", 2000)
            if sol.check() == unsat:
                self.formula = Not(self.formula)
                # print("!!convert unsat to sat??")

    def init_from_file(self, seed):
        """
        Initialize from an SMT-LIB2 file
        """
        try:
            script = get_script_from_file(seed)
            # new_script = self.shift_script(script)
            new_script = script
            self.assertions = parse_smt2_string(new_script)
            len_ass = len(self.assertions)
            if len_ass < 1:
                return
            elif len_ass == 1:
                self.formula = self.assertions[0]
            else:
                self.formula = And(self.assertions)
            self.vars = get_vars(self.formula)
            self.has_quantifier = self.has_quant()
            for p in get_atoms(self.formula):
                if not (is_true(p) or is_false(p)):
                    self.preds.append(p)
            self.success = True
            if random.random() < 0.5:
                self.to_sat_formula()
        except Exception as ex:
            print("error while parsing orig smt file")
            print(ex)

    def enable_z3_option(self):
        self.z3option = True

    def enable_cvc4_option(self):
        self.cvc4option = True

    def init_from_str(self, strf):
        """
        Initialize from a string
        """
        try:
            new_script = shift_script(strf)
            self.assertions = parse_smt2_string(new_script)
            len_ass = len(self.assertions)
            if len_ass < 1:
                return
            elif len_ass == 1:
                self.formula = self.assertions[0]
            else:
                self.formula = And(self.assertions)
            self.vars = get_vars(self.formula)
            self.has_quantifier = self.has_quant()
            for p in get_atoms(self.formula):
                if not (is_true(p) or is_false(p)):
                    self.preds.append(p)
            self.success = True
            # if random.random() < 0.5: self.to_sat_formula()
        except Exception as ex:
            print("error while parsing orig smt file")
            print(ex)

    def get_quant_mutant_as_str(self):
        """
        Mutation strategy 1: add quantifiers
        """
        if len(self.vars) == 0:
            sol = Solver()
            sol.add(self.formula)
            return sol.to_smt2()

        add_quant_swarm = [0.33, 0.44, 0.55, 0.66]
        quant_type_swarm = [0.33, 0.44, 0.55, 0.66]

        new_fml = self.formula
        random.shuffle(self.vars)
        for var in self.vars:
            if random.random() < random.choice(add_quant_swarm):
                qvars = [var]
                if random.random() < random.choice(quant_type_swarm):
                    new_fml = Exists(qvars, new_fml)
                else:
                    new_fml = ForAll(qvars, new_fml)
        sol = Solver()
        sol.add(new_fml)
        return sol.to_smt2()

    def get_boolean_combination_mutant(self):
        """
        Mutation strategy 2: new boolean combination (only use existing atoms)
        """
        max_assert = random.randint(10, 80)
        ass = []
        for _ in range(max_assert):
            clen = random.randint(1, 8)
            if clen == 1:
                cls = random.choice(self.preds)
                ass.append(cls)
            else:
                if random.random() < 0.5:
                    cls = And(random.sample(self.preds, min(len(self.preds), clen)))
                else:
                    cls = Or(random.sample(self.preds, min(len(self.preds), clen)))
                ass.append(cls)
            ass.append(cls)
        return And(ass)

    def extract_literals_square(self):
        """
        1. convert to CNF
        2. extract clauses in the CNF
        :return:  [[l1, l2, l3], [l2, l4], ..., ]
        """
        res = []
        tac = Then(Tactic("simplify"), Tactic("tseitin-cnf"))
        clauses = tac(self.formula)[0]
        # print(clauses)
        for cls in clauses:
            if is_or(cls):
                tmp_cls = []
                for lit in cls.children():
                    tmp_cls.append(lit)
                res.append(tmp_cls)
            else:
                res.append([cls])
        return res

    def get_domain_mutant_as_str(self):
        """
        Add abstract domain cnts
        :return:
        """
        int_or_real_var = []
        for var in self.vars:
            if is_int(var) or is_real(var):
                int_or_real_var.append(var)
        if len(int_or_real_var) < 1:
            return self.get_quant_mutant_as_str()

        sol = Solver()
        sol.add(self.formula)
        idx = 0
        domain_cnts_names = []
        for _ in range(10):
            cls_names = []
            for var in int_or_real_var:
                rr = random.random()
                if rr < 0.333:
                    domain_cnt = var < random.randint(-100, 100)
                elif rr < 0.666:
                    domain_cnt = var == random.randint(-100, 100)
                else:
                    domain_cnt = var > random.randint(-100, 100)
                idx += 1
                bi = Bool("l" + str(idx))
                sol.add(bi == domain_cnt)
                cls_names.append("l" + str(idx))
            domain_cnts_names.append(cls_names)

        smt2_string = sol.to_smt2()
        for cnts in domain_cnts_names:
            s = " "
            for ass in list(cnts):
                s += ass
                s += " "
            smt2_string += "(check-sat-assuming ({}))\n".format(s)
        return smt2_string

    def get_cube_mutant_as_str(self):
        if len(self.preds) <= 1:
            return self.get_quant_mutant_as_str()
        sol = Solver()
        sol.add(self.formula)
        preds_names = []
        i = 0
        for pred in self.preds:
            bi = Bool("l" + str(i))
            preds_names.append("l" + str(i))
            sol.add(bi == pred)
            i = i + 1

        smt2_string = sol.to_smt2()
        # TODO: 1. sample 50%, 75%, 100% of the full set?
        #       2. Consider also the negation of an atom
        for _ in range(10):
            cube = ""
            sample_preds = random.sample(preds_names, random.randint(2, len(self.preds)))
            for p in sample_preds:
                cube += p
                cube += " "
            smt2_string += "(check-sat-assuming ({}))\n".format(cube)
        return smt2_string

    def get_assuming_mutant_as_str(self):
        """
        Enumerate cubes from CNF
        :return:
        """
        if len(self.preds) <= 1:
            return self.get_quant_mutant_as_str()
        squares = self.extract_literals_square()
        sol = Solver()
        sol.add(self.formula)
        i = 0
        lits_names = []
        # print(self.formula)
        # print(squares)
        for cls in squares:
            cls_names = []
            for lit in cls:
                i += 1
                bi = Bool("l" + str(i))
                cls_names.append("l" + str(i))
                sol.add(bi == lit)
            lits_names.append(cls_names)

        smt2_string = sol.to_smt2()
        total_cubes = 1
        for cls_names in lits_names:
            total_cubes = total_cubes * len(cls_names)
        # print("tatal, ", total_cubes)
        # smt2_string += "; total cubes {}".format(str(total_cubes))
        id = 0
        random.shuffle(lits_names)
        for element in itertools.product(*lits_names):
            s = " "
            for ass in list(element):
                s += ass
                s += " "
            smt2_string += "(check-sat-assuming ({}))\n".format(s)
            id += 1
            if id > 30:
                break
        return smt2_string

    def get_mutant_as_str(self):
        """
        External interface for retuning mutant as a string
        """
        if random.random() < 0.5:
            smt2_string = self.get_cube_mutant_as_str()
        else:
            smt2_string = self.get_domain_mutant_as_str()
        return smt2_string


def main(problem_file, output_file, mode):
    z3_gene = Z3Mutation()
    z3_gene.init_from_file(problem_file)
    # Generate the mutant to the file

    try:
        final_fml_str = ""
        # guess_logic = z3_gene.get_logic()
        # if guess_logic != "ALL":
        #    logic_cmd = "(set-logic " + guess_logic + ")\n"
        #    final_fml_str += logic_cmd
        smt2_string = ""
        if z3_gene.success:
            if mode == "quant":
                smt2_string = z3_gene.get_quant_mutant_as_str()
            elif mode == "cube":
                smt2_string = z3_gene.get_cube_mutant_as_str()
            elif mode == "domain":
                smt2_string = z3_gene.get_domain_mutant_as_str()
            elif mode == "inter":
                # FIME: add the implementaiton
                smt2_string = None
            else:
                smt2_string = z3_gene.get_mutant_as_str()
        final_fml_str += smt2_string
        # add incremental
        if random.random() < 0.5:
            if random.random() < 0.5:
                final_fml_str += "(push 1)\n"
            final_fml_str += "(check-sat)\n"
        # finally, write to file
        string2file(output_file, final_fml_str)
    except Exception as ex:
        print("fatal failure in mutating!")
        print(ex)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--input', dest='input', default='default', type=str)
    parser.add_argument('--output', dest='output', default='default', type=str)
    parser.add_argument('--mode', dest='mode', default='default', type=str)
    parser.add_argument('--optionmode', dest='optionmode', default='none', type=str)
    args = parser.parse_args()

    main(args.input, args.output, args.mode)
